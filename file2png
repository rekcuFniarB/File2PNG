#!/bin/sh

##  File2PNG script. Store any file as PNG image.
##  Copyright (C) 2018  BrainFucker <retratserif@gmail.com>
##  
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##  
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.

VERSION='0.6'

_NAME_="$(basename "$0")"

USAGE="USAGE
    $_NAME_ -store input_file output_file.png
        Store input_file as output_file.png
    
    $_NAME_ -restore input_file.png output_file
        Restore file from input_file.png
        Will save original file name saved to same directory as input file
        if no output file supplied.
    
    $_NAME_ -info input_file.png
        Print file info.
    
    $_NAME_ -bitdepth
        Force image bit depth. Using 16 by default. Supported values: 8 or 16.
    
    $_NAME -force
        Force output even if decode failed.
    
    $_NAME_ -help
        Print this help.
    

COPYRIGHT
    File2PNG $VERSION Copyright (C) 2018  BrainFucker
    This program comes with ABSOLUTELY NO WARRANTY.
    This is free software, and you are welcome to redistribute it
    under certain conditions."

## print messages to stderr
errlog () {
    echo "$@" 1>&2
}

## Args parser
## Supported arg formats:
##     -arg --arg (both are identical)
##     -arg value
##     -arg=value
parse_args() {
    local ARG _PREV_ARG _ARG _VAR _VAL _ARGN SKIP
    __ARGS=''
    for ARG in "$@"; do
        case "$ARG" in
            --) _PREV_ARG=''
                SKIP=1 ;;
            -[-a-zA-Z0-9]*) if [ -z "$SKIP" ]; then
                    _ARG="$(echo -n "$ARG" | sed 's/^-\+//' | sed 's/-/_/g' | tr -d '\r' | tr '\t\v\n' ' ')"
                    case "$_ARG" in
                        *=*) _PREV_ARG=''
                             _VAR="$(echo -n "$_ARG" | sed 's/=.*//')"
                             _VAL="$(echo -n "$_ARG" | sed 's/.\+=//')"
                             if [ -z "$_VAL" ]; then
                                 _VAL=0
                             fi
                             __ARGS="$__ARGS\n__arg_${_VAR}__ $_VAL"
                             eval "_arg_$_VAR=\$_VAL" ;;
                          *) _PREV_ARG="_arg_$_ARG"
                             __ARGS="$__ARGS\n__arg_${_ARG}__ 1"
                             eval "_arg_$_ARG=1" ;;
                    esac
                fi ;;
            *) if [ -n "$_PREV_ARG" ]; then
                   __ARGS="$__ARGS\n_${_PREV_ARG}__ $ARG"
                   eval "$_PREV_ARG=\$ARG"
                   _PREV_ARG=''
               else
                   _ARGN=$((_ARGN+1))
                   __ARGS="$__ARGS\n__arg_${_ARGN}__ $_ARG"
                   eval "_arg$_ARGN=\$ARG"
               fi ;;
        esac
    done
} # parse_args()

## get arg value
## $1 arg name
fn_get_arg() {
    echo -n "$__ARGS" | grep "__arg_$1__" | tail -n 1 | sed "s/__arg_$1__ //"
}

## check for installed required utils
UTILS="convert sha256sum dd bc awk grep mktemp sed"
for anutil in $UTILS; do
    if [ _"$(which "$anutil")" = _ ]; then
        errlog "Error: util $anutil not found."
        exit 1
    fi
done

parse_args "$@"

## Exit if no args supplied
if [ _"$1" = _ ] || [ _"$2" = _ ]; then
    errlog "$USAGE"
    exit 0
fi

fn_check_file() {
    local FILE
    local DEV
    
    if [ _"$2" != _"out" ] && [ _"$2" != _"in" ]; then
        DEV='/dev/stdin'
    else
        DEV="/dev/std$2"
    fi
    
    if [ _"$1" = _- ]; then
        ## Read from stdin if supplied filename is -
        FILE="$DEV"
    else
        FILE="$1"
        ## Exit if file not exists
        if [ ! -f "$FILE" ]; then
            errlog "File $FILE not exists."
            exit 1
        fi
    fi
    echo "$FILE"
}

## Show supplied file info
showinfo () {
    INFO="$(convert PNG:"$1" RGB:-   | grep -a '###')"
    echo "$INFO" | grep -a '###NAME:'    | sed 's/###//g'
    echo "$INFO" | grep -a '###SIZE:'    | sed 's/###//g'
    echo "$INFO" | grep -a '###SHA256:'  | sed 's/###//g'
    echo "$INFO" | grep -a '###VERSION:' | sed 's/###//g'
} # showinfo

## restore file
## $1 input file
## $2 output file
restorefile () {
    local IN OUT
    _RAW="$(mktemp)"
    IN="$(fn_check_file "$1" in)"
    #OUT="$(fn_check_file "$2" out)"
    convert PNG:"$IN" RGB:"$_RAW"
    
    INFO="$( grep -a '###' "$_RAW" )"
    _SIZE="$(    echo -n "$INFO" | grep -a '###SIZE:'    | awk '{print $2}')"
    _SHA="$(     echo -n "$INFO" | grep -a '###SHA256:'  | awk '{print $2}')"
    _VERSION="$( echo -n "$INFO" | grep -a '###VERSION:' | awk '{print $2}')"
    _NAME="$(    echo -n "$INFO" | grep -a '###NAME:'    | sed 's/###NAME: //' | sed 's/ ###//')"
    
    if [ -z "$2" ]; then
        DIR="$(dirname "$IN")"
        OUTPUT="$DIR/$_NAME"
    else
        OUTPUT="$2"
    fi

    if [ _"$_SIZE" = _ ] || [ _"$_NAME" = _ ] || [ _"$_SHA" = _ ]; then
        errlog "No data found inside. Restoring failed."
        _SIZE=''
        if [ -z "$_arg_force" ]; then
            rm "$_RAW"
            exit 1
        fi
    fi
    
    if [ _"$_VERSION" != _"$VERSION" ]; then
        errlog "Warning: file was created by different version of $_NAME_."
    fi
    
    if [ -n "$_SIZE" ]; then
        _SIZE="bs=$_SIZE"
    fi
    
    if [ _"$OUTPUT" = _'-' ]; then
        OUTPUT='/dev/stdout'
        dd if="$_RAW" $_SIZE count=1
    else
        dd if="$_RAW" of="$OUTPUT" $_SIZE count=1
    fi
    
    rm "$_RAW"

    if [ _"$OUTPUT" != _'/dev/stdout' ]; then
        echo "$OUTPUT"
        
        _NEWSHA="$(sha256sum "$OUTPUT" | awk '{print $1}')"
        if [ _"$_NEWSHA" != _"$_SHA" ]; then
            errlog "Sha sums not equal, something weng wrong.
            Original: $_SHA
            Output:   $_NEWSHA"
            exit 1
        fi
    fi
} # restorefile

## store file
## $1 input file
## $2 output file
storefile () {
    ## force 8 bit depth by setting this env variable
    ## some image hosters don't like 16bit.
    ## using 16 bit by default
    if [ -z "$_arg_bitdepth" ]; then
        _arg_bitdepth=16
    fi
    
    IN="$(fn_check_file "$1" in)"
    #OUT="$(fn_check_file "$2" out)"
    OUT="$2"
    
    ## bytes per 3 color pixel
    PIXBYTE=$(( $_arg_bitdepth * 3 / 8 ))
    
    if [ _"$IN" = _'/dev/stdin' ] || [ _"$OUT" = _'/dev/stdout' ]; then
        errlog "Stdin and stdout not supported for this type of operation."
        exit 1
    fi
    
    NAME="$(basename "$IN")"
    
    if [ -z "$OUT" ]; then
        OUTPUT="$(mktemp 'XXXXXXXXXX.png')"
    else
        OUTPUT="$OUT"
    fi
    
    SHA="$(sha256sum "$IN" | awk '{print $1}')"

    SIZE="$(stat -c '%s' "$IN")"

    TMP="$(mktemp)"

    cp "$IN" "$TMP"

    ## Store metadata
    echo '' >> "$TMP"
    echo "###SIZE: $SIZE ###"  >> "$TMP"
    echo "###NAME: $NAME ###"  >> "$TMP"
    echo "###SHA256: $SHA ###" >> "$TMP"
    echo "###VERSION: $VERSION ###" >> "$TMP"

    SIZE="$(stat -c '%s' "$TMP")"
    
    _PIXELS=$(( $SIZE  / $PIXBYTE ))
    
    errlog "TMP pixels: $_PIXELS"
    
    RESOL="$(echo "sqrt($_PIXELS) +1" | bc)"
    
    errlog "Target resolution: ${RESOL}x${RESOL}"
    
    PIXELS=$(( $RESOL * $RESOL ))
    
    ## calculating target size
    CONTAINERSIZE=$(( $PIXELS * $PIXBYTE ))
    
    errlog "Container size: $CONTAINERSIZE"
    
    BYTESDIFF=$(( $CONTAINERSIZE - $SIZE ))
    
    
    if [ $BYTESDIFF -gt 0 ]; then
        ## adding missing bytes
        dd if=/dev/zero bs=$BYTESDIFF count=1 >> "$TMP"
    elif [ $BYTESDIFF -lt 0 ]; then
        errlog "Error: unexpected container size."
        exit 1
    fi
    
    convert -size ${RESOL}x${RESOL} -depth $_arg_bitdepth RGB:"$TMP" PNG00:"$OUTPUT"

    echo "$OUTPUT"
    
    rm "$TMP"
} # storefile()

if [ -n "$_arg_help" ] || [ -n "$_arg_h" ]; then
    errlog "$USAGE"
    exit 0
elif [ -n "$_arg_info" ]; then
    showinfo "$_arg_info"
    exit 0
elif [ -n "$_arg_restore" ]; then
    restorefile "$_arg_restore" "$_arg1"
    exit 0
elif [ -n "$_arg_store" ]; then
    storefile "$_arg_store" "$_arg1"
    exit 0
else
    errlog "$USAGE"
    exit 1
fi
